import os, sys
import numpy as np
import math
from PyQt5.QtCore import pyqtSignal
sys.path.append(os.path.abspath('..'))
from PyQt5 import QtWidgets

from utils import geometry
from utils.varia import mm, µm, nm, deg, X, Y
from utils import varia
from utils.optics import N_air, N_glass
from utils.configuration_class import config


WAVELENGTH_DEFAULT = 660*nm




class LightSourceClass(QtWidgets.QWidget):
    nr_of_sources = 0
    update_source_progress_signal = pyqtSignal(float)

    def __init__(self, p0=np.array([0,0]), n0=np.array([1,0]), intensity=1, wavelength=WAVELENGTH_DEFAULT, plot_color=varia.colormap_wavelength(wavelength=WAVELENGTH_DEFAULT), is_visible=True, is_virtual=False):
        self.wavelength = wavelength
        self.intensity = intensity
        self.p0 = np.array(p0)
        self.n0 = geometry.normalize(np.array(n0))
        self.plot_color = plot_color
        self.is_visible = is_visible
        self.is_virtual = is_virtual

        super().__init__()
        self.reset()
        self.r = geometry.orientation_from_normal(self.n0)

        self.ID = LightSourceClass.nr_of_sources
        LightSourceClass.nr_of_sources += 1
        self.name = None

    def reset(self):
        self.rays = list()
        self.nr_of_rays = 0  # Total number of rays in the source, original and newly formed rays by the raytracing algorithm
        self.nr_of_original_rays = 0  # The number of original rays generated by the source
        self.intensity_min = np.inf
        self.intensity_max = 0
        RayClass.nr_of_rays = 0     # For each light source, the RayClass counter is reset too

    def add_ray(self, ray):
        # Add new ray to the list
        self.rays.append(ray)
        self.nr_of_rays += 1
        if ray.intensity is not None:
            self.update_min_max_intensity(ray)  # Laser rays have initially intensity 0, but "get" intensity as soon as we know where it hits a surface"

    def update_min_max_intensity(self, ray):
        self.intensity_min = np.min([self.intensity_min, ray.intensity])
        self.intensity_max = np.max([self.intensity_max, ray.intensity])

    def __str__(self):
        txt = f'Light source nr {self.ID+1}: ID={self.ID}, nr of rays={self.nr_of_rays}'
        return txt

    def plot(self, graph):
        # Determine what rays to plot
        from utils.configuration_class import config
        self.nr_of_rays_to_plot = np.min([self.nr_of_original_rays, config.getint('view', 'nr_of_rays_to_plot')])

        print(f' --> Plotting rays of source {self.ID+1}/{LightSourceClass.nr_of_sources} ({self.nr_of_rays_to_plot} rays)')
        if self.nr_of_rays_to_plot == 1:
            ID_list = [int(self.nr_of_original_rays/2)]
        else:
            ID_list = np.round(np.linspace(0, self.nr_of_original_rays - 1, self.nr_of_rays_to_plot))
            ID_list = ID_list.astype(int)

        # Plot all the rays in the to-plot list
        for i_ID in range(self.nr_of_rays_to_plot):
            ID_ray = ID_list[i_ID]
            varia.print_progress(i_ID, self.nr_of_rays_to_plot)
            ray = self.rays[ID_ray]
            self.plot_ray_and_children(graph, ray)
            self.update_source_progress_signal.emit((i_ID + 1) / self.nr_of_rays_to_plot)

    def plot_ray_and_children(self, graph, ray):
        # Define the line width, based on the number of rays
        if self.nr_of_rays_to_plot <= 10:     linewidth = 2
        elif self.nr_of_rays_to_plot <= 100:  linewidth = 1
        else:                                 linewidth = 0.5

        # Define the relation between ray intensity and color representation
        from utils.configuration_class import config
        if config.getboolean('view', 'intensity_coded_colors'):  int_rep_offset, int_rep_linear, int_rep_offset2, int_rep_linear2 = 0.0, 0.1, 0.01, 0.1
        else:                                                    int_rep_offset, int_rep_linear, int_rep_offset2, int_rep_linear2 = 1.0, 0.0, 1.00, 0.0

        # if self.intensity_max is 0:
        #     intensity_representation = 0.5
        #     col = 'black'
        if ray.length is not None:        # A ray has length when it hits an object
            # intensity_representation = int_rep_offset + int_rep_linear*np.power(ray.intensity / self.intensity_max, 1)
            # intensity_representation = int_rep_offset + int_rep_linear*np.power(ray.intensity / self.intensity_max, 1)
            intensity_representation = int_rep_offset + (ray.intensity / self.intensity_max)**2
            col = ray.plot_color
        elif ray.intensity is not None:        # The ray shoots into the great nothing, no length is defined, and plotted grey
            # intensity_representation = int_rep_offset2 + int_rep_linear2*np.power(ray.intensity / self.intensity_max, 1)
            intensity_representation = int_rep_offset2 + (ray.intensity / self.intensity_max)**2
            col = 'lightgrey'
        else:
            intensity_representation = 0.5
            col = 'lightgrey'

        # First, plot that ray (segment) itself
        ray.plot(graph, linewidth=linewidth, col=col, intensity_representation=intensity_representation)

        # Then, plot all of its children
        for ID_child in ray.ID_children:
            ray_child = self.rays[ID_child]
            self.plot_ray_and_children(graph, ray_child)



class RayClass:
    nr_of_rays = 0

    def __init__(self, p0=np.array([0,0]), r=np.array([1,0]), wavelength=WAVELENGTH_DEFAULT, N=N_air, intensity=None, ray_parent=None, source_element=None, plot_color=varia.colormap_wavelength(wavelength=WAVELENGTH_DEFAULT), is_active=True, is_visible=True, is_virtual=False):

        self.p0 = p0                            # starting point of the ray
        self.r = geometry.normalize(r)          # Orientation of the ray
        self.wavelength = wavelength            # Wavelength of the ray
        self.N = N                              # In what medium (refraction index) does the ray move
        self.source_element = source_element    # Where does the ray originates from
        self.intensity  = intensity
        self.is_active  = is_active
        self.is_visible = is_visible
        self.is_virtual = is_virtual
        self.plot_color = plot_color

        self.display_ID      = None  # With what display nr the ray intersects
        self.display_x       = None  # Where on the display the ray hits, relatively with one side of the display as x=0
        self.imager_pixel_ID = None  # With what pixel the ray intersects on the imager

        self.ID = RayClass.nr_of_rays
        RayClass.nr_of_rays += 1

        # Track parent and children information
        self.ID_parent = []
        self.ID_children = []
        if ray_parent is not None:
            self.ID_parent = ray_parent.ID
            self.phase_start = ray_parent.phase_end

        self.reset()

    def reset(self):
        self._p1 = None             # The end point of the ray is a private member. This cannot be simply set, a setter method is used.
        self.element_hit = None
        self.length = None
        self.optical_path_length = None
        self.p1_element_rel = np.nan
        self.phase_start = 0        # Phase at the start of the ray
        self.phase_end = None       # Phase at the end of the ray
        self.phase_shift = None     # Phase change during its travel
        if self.plot_color is None:
            self.plot_color = varia.colormap_wavelength(self.wavelength)

    @property
    def p1(self):
        return self._p1

    # When the endpoint of a ray is set, its length, phase and (for a laser) intensity must be computed too
    @p1.setter
    def p1(self, val):
        self._p1 = val

        if self.length is None:
            self.length = geometry.distance_between_2_points(self.p0, self.p1)

        self.optical_path_length = self.N * self.length
        self.phase_shift = 2 * np.pi / self.wavelength * self.optical_path_length
        self.phase_end = self.phase_start + self.phase_shift
        self.phase_end = math.fmod(self.phase_end, 2 * math.pi) - math.pi

        # For "normal" light, the intensity of the active ray is what it is at the start, at initialisation
        # For laser light, the intensity of the active (!) ray depends on its position along the (cross-section of the) Gaussian beam
        from light import laser_class   # A "Lazy import", put it here, where we use it. If put at the beginning of the file, we create a circular import dependency
        if isinstance(self.source_element, laser_class.LaserClass):
            self.intensity = self.source_element.calculate_intensity_at_P(P=self.p1)
            self.source_element.update_min_max_intensity(self)

    def __str__(self):
        r_str  = varia.format_1D_array(arr=self.r,  fmt='7.4f')
        p0_str = varia.format_1D_array(arr=self.p0, fmt='7.4f')
        p1_str = varia.format_1D_array(arr=self.p1, fmt='7.4f') if self.p1 is not None else f'None'
        length_str = f'{self.length:7.4f}' if self.length is not None else 'None'
        intensity_str = 'None' if self.intensity is None else f'{self.intensity:6.3f}'
        sourceID_str = f'{self.source_element.name} {self.source_element.ID}' if self.source_element is not None else f'{self.source_element}'
        s = f'Ray nr {self.ID+1}/{RayClass.nr_of_rays} --> ID= {self.ID}, p0={p0_str}, p1={p1_str}, length={length_str}, r={r_str}, angle={geometry.angle_from_vector(self.r)/deg:6.2f}°, wavelength={self.wavelength/nm:.0f}nm, intensity={intensity_str}, source={sourceID_str}, plot color={self.plot_color}'
        return s

    def plot(self, graph, linewidth, col, intensity_representation):
        if not self.is_visible:
            return

        if (self.length is None)  and  (not config.getboolean('view', 'show_noncolliding_rays')):
            return

        intensity_scaler = config.getfloat('view', 'intensity_scaler')
        intensity_representation_scaled = np.min([intensity_scaler*intensity_representation, 1])

        # # Convert to RGB colors
        # if isinstance(col, str):
        #     col = matplotlib.colors.to_rgb(col)
        col = varia.load_colormap(color=col, N_rays=1, wavelength=self.wavelength)

        # A bug when simulating a single ray --> TO DEBUG
        if not isinstance(col, tuple):
            col = col[0]
            if not isinstance(col, tuple):
                col = col[0]
        col = (col[0], col[1], col[2], intensity_representation_scaled)

        # Show rays not hitting an object as short grey lines
        length_of_non_colliding_rays = 5
        p1 = self.p1   if   self.length is not None   else self.p0 + self.r * length_of_non_colliding_rays

        # Plot the ray segment
        graph.plot([self.p0[X], p1[X]], [self.p0[Y], p1[Y]], color=col, linewidth=linewidth, linestyle='solid')




if __name__ == '__main__':
    # The app is needed because the LightSourceClass inherits from QWidget, otherwise it will crash
    # It 's the core event loop and initialization hub for all Qt objects.
    app = QtWidgets.QApplication(sys.argv)
    light = LightSourceClass()
    print(light)